begin;

-- Ensure required schema and extension exist
create schema if not exists clinical;
create extension if not exists pgcrypto;

/*
  Consolidate triage tables into the clinical schema.
  The logic handles three possible states:
    1. Tables already in clinical -> no move needed.
    2. Tables only in public     -> move them into clinical.
    3. Tables duplicated in both -> merge data then drop the public copies.
*/
do $$
declare
  has_clinical_sessions boolean := exists (
    select 1
      from information_schema.tables
     where table_schema = 'clinical'
       and table_name   = 'triage_sessions'
  );
  has_public_sessions boolean := exists (
    select 1
      from information_schema.tables
     where table_schema = 'public'
       and table_name   = 'triage_sessions'
  );
  has_public_messages boolean := exists (
    select 1
      from information_schema.tables
     where table_schema = 'public'
       and table_name   = 'triage_messages'
  );
begin
  -- Move from public -> clinical when clinical tables are missing.
  if not has_clinical_sessions and has_public_sessions then
    if has_public_messages then
      execute 'alter table public.triage_messages drop constraint if exists triage_messages_session_id_fkey';
    end if;
    execute 'alter table public.triage_sessions set schema clinical';
    if has_public_messages then
      execute 'alter table public.triage_messages set schema clinical';
      execute 'alter table clinical.triage_messages add constraint triage_messages_session_id_fkey foreign key (session_id) references clinical.triage_sessions(id) on delete cascade';
    end if;
    return;
  end if;

  -- If both schemas have copies, merge data into clinical and drop the public copies.
  if has_clinical_sessions and has_public_sessions then
    -- Ensure the clinical messages table exists before merging
    if not exists (
      select 1
        from information_schema.tables
       where table_schema = 'clinical'
         and table_name   = 'triage_messages'
    ) then
      execute '
        create table clinical.triage_messages (
          id bigint generated by default as identity primary key,
          session_id uuid not null references clinical.triage_sessions(id) on delete cascade,
          role text not null check (role in (''user'',''ai'',''system'',''doctor'')),
          content text not null,
          metadata jsonb not null default ''{}''::jsonb,
          created_at timestamptz not null default now()
        )';
    end if;

    execute '
      insert into clinical.triage_sessions (id, patient_id, doctor_id, status, risk_level, summary, created_at, updated_at, completed_at)
      select id, patient_id, doctor_id, status, risk_level, summary, created_at, updated_at, completed_at
        from public.triage_sessions
      on conflict (id) do update
        set patient_id = excluded.patient_id,
            doctor_id = excluded.doctor_id,
            status = excluded.status,
            risk_level = excluded.risk_level,
            summary = excluded.summary,
            created_at = excluded.created_at,
            updated_at = excluded.updated_at,
            completed_at = excluded.completed_at';

    if has_public_messages then
      execute '
        insert into clinical.triage_messages (id, session_id, role, content, metadata, created_at)
        select id, session_id, role, content, metadata, created_at
          from public.triage_messages
        on conflict (id) do nothing';
    end if;

    execute 'drop table if exists public.triage_messages cascade';
    execute 'drop table if exists public.triage_sessions cascade';
    return;
  end if;
end $$;

-- Create tables in clinical schema if they are still missing
create table if not exists clinical.triage_sessions (
  id uuid primary key default gen_random_uuid(),
  patient_id uuid not null references auth.users(id) on delete cascade,
  doctor_id uuid references auth.users(id),
  status text not null default 'active' check (status in ('active', 'completed', 'cancelled')),
  risk_level text check (risk_level in ('low', 'moderate', 'high', 'emergency')),
  summary jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  completed_at timestamptz
);

create table if not exists clinical.triage_messages (
  id bigint generated by default as identity primary key,
  session_id uuid not null references clinical.triage_sessions(id) on delete cascade,
  role text not null check (role in ('user', 'ai', 'system', 'doctor')),
  content text not null,
  metadata jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now()
);

-- Indexes
create index if not exists triage_sessions_patient_idx on clinical.triage_sessions (patient_id);
create index if not exists triage_sessions_doctor_idx on clinical.triage_sessions (doctor_id);
create index if not exists triage_sessions_status_idx on clinical.triage_sessions (status);
create index if not exists triage_sessions_risk_level_idx on clinical.triage_sessions (risk_level);
create index if not exists triage_sessions_created_at_idx on clinical.triage_sessions (created_at);

create index if not exists triage_messages_session_idx on clinical.triage_messages (session_id);
create index if not exists triage_messages_role_idx on clinical.triage_messages (role);
create index if not exists triage_messages_created_at_idx on clinical.triage_messages (created_at);

-- Row level security and policies
alter table clinical.triage_sessions enable row level security;
alter table clinical.triage_messages enable row level security;

drop policy if exists patient_select_triage_sessions on clinical.triage_sessions;
create policy patient_select_triage_sessions
  on clinical.triage_sessions
  for select
  using (patient_id = auth.uid());

drop policy if exists patient_insert_triage_sessions on clinical.triage_sessions;
create policy patient_insert_triage_sessions
  on clinical.triage_sessions
  for insert
  with check (patient_id = auth.uid());

drop policy if exists patient_update_triage_sessions on clinical.triage_sessions;
create policy patient_update_triage_sessions
  on clinical.triage_sessions
  for update
  using (patient_id = auth.uid())
  with check (patient_id = auth.uid());

drop policy if exists doctor_select_triage_sessions on clinical.triage_sessions;
create policy doctor_select_triage_sessions
  on clinical.triage_sessions
  for select
  using (doctor_id = auth.uid());

drop policy if exists doctor_update_triage_sessions on clinical.triage_sessions;
create policy doctor_update_triage_sessions
  on clinical.triage_sessions
  for update
  using (doctor_id = auth.uid())
  with check (doctor_id = auth.uid());

drop policy if exists patient_select_triage_messages on clinical.triage_messages;
create policy patient_select_triage_messages
  on clinical.triage_messages
  for select
  using (
    exists (
      select 1
        from clinical.triage_sessions s
       where s.id = session_id
         and s.patient_id = auth.uid()
    )
  );

drop policy if exists patient_insert_triage_messages on clinical.triage_messages;
create policy patient_insert_triage_messages
  on clinical.triage_messages
  for insert
  with check (
    exists (
      select 1
        from clinical.triage_sessions s
       where s.id = session_id
         and s.patient_id = auth.uid()
    )
  );

drop policy if exists doctor_select_triage_messages on clinical.triage_messages;
create policy doctor_select_triage_messages
  on clinical.triage_messages
  for select
  using (
    exists (
      select 1
        from clinical.triage_sessions s
       where s.id = session_id
         and s.doctor_id = auth.uid()
    )
  );

drop policy if exists doctor_insert_triage_messages on clinical.triage_messages;
create policy doctor_insert_triage_messages
  on clinical.triage_messages
  for insert
  with check (
    exists (
      select 1
        from clinical.triage_sessions s
       where s.id = session_id
         and s.doctor_id = auth.uid()
    )
  );

-- Trigger to keep session updated_at in sync
create or replace function clinical.touch_triage_session()
returns trigger
language plpgsql
as $$
begin
  update clinical.triage_sessions
     set updated_at = now()
   where id = new.session_id;
  return new;
end;
$$;

drop trigger if exists trg_triage_messages_touch_session on clinical.triage_messages;
create trigger trg_triage_messages_touch_session
after insert or update on clinical.triage_messages
for each row execute function clinical.touch_triage_session();

-- Ensure authenticated role can access the schema (RLS still applies)
grant usage on schema clinical to authenticated;
grant select, insert, update on clinical.triage_sessions to authenticated;
grant select, insert, update on clinical.triage_messages to authenticated;

commit;
